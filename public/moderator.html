<!DOCTYPE html>
 <html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link id="theme-stylesheet" rel="stylesheet" href="/themes/moderator/default.css">
  <title>Moderator Panel</title>
  <style>
    .toast {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background-color: #4caf50;
      color: white;
      padding: 16px 24px;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      font-size: 14px;
      font-weight: 500;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
      z-index: 1000;
    }

    .toast.show {
      opacity: 1;
      visibility: visible;
    }
  </style>
</head>
<body>
  <!-- Toast Notification -->
  <div id="toast" class="toast"></div>

  <h1>Moderator Panel</h1>
  <button onclick="window.location.href='/moderator_logout'">Logoff</button>
  <button id="configure-event-button" onclick="toggleConfigureEvent()">Configure Event</button>

  <div id="configure-event" style="display: none; margin-top: 20px; border: 1px solid #ccc; padding: 10px;">
    <h3>Event Configuration</h3>
    <label for="event-name">Event Name:</label>
    <input type="text" id="event-name" placeholder="Enter event name"><br><br>

    <label for="event-url-field">URL:</label>
    <input type="text" id="event-url-field" placeholder="Example: 01.02.03.04"><br><br>

    <label for="event-datetime">Event Date and Time:</label>
    <input type="datetime-local" id="event-datetime" placeholder="Select event date and time"><br><br>

    <h4>Theme Selection</h4>
    <label>User theme:
      <select id="theme-index"></select>
    </label><br>
    <label>Live theme:
      <select id="theme-live"></select>
    </label><br>
    <label>Moderator theme:
      <select id="theme-moderator"></select>
    </label><br>
    <label>Presenter theme:
      <select id="theme-presenter"></select>
    </label><br><br>

    <button onclick="saveEventConfig()">Update</button>
  </div>

  <!-- Top panel for sorting and live question -->
  <div id="top-panel">
    <!-- Add sorting buttons -->
    <div id="sorting-controls">
      <button onclick="changeSort('recency')">Sort by Recency</button>
      <button onclick="changeSort('approved')">Sort by Approved</button>
      <button onclick="changeSort('votes')">Sort by Votes</button>
    </div>
    <!-- Live question area -->
    <div id="live-question-area"></div>
    <!-- Next Up question area -->
    <div id="next-up-question-area"></div>
  </div>

  <!-- Question list container -->
  <div id="questions"></div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    let currentSort = 'recency'; // Default sort order

    // Listen for all questions and update the list
    socket.on('all_questions', (questions) => {
      updateQuestionList(questions);
    });

    socket.on('live_question', (question) => {
      const liveQuestionArea = document.getElementById('live-question-area');
      if (question) {
        liveQuestionArea.innerHTML = `
          <h3>Live Question</h3>
          <div class="question live" data-id="${question.id}">
            <div class="question-text">${question.text} | <span class="vote-count">Votes: ${question.upvotes}</span></div>
            <div class="username">Submitted by: ${question.username}</div>
            <div class="timestamp">Submitted on: ${new Date(question.created_at).toLocaleString()}</div>
            <div class="buttons">
              <button onclick="cancelLive('${question.id}')">Cancel</button>
              <button onclick="archive_question('${question.id}')">Archive</button>
            </div>
          </div>
        `;
      } else {
        liveQuestionArea.innerHTML = '';
      }
    });

    // Show the Next Up question in the top panel
    socket.on('next_up_question', (question) => {
      const nextUpArea = document.getElementById('next-up-question-area');
      if (question) {
        nextUpArea.innerHTML = `
          <h3>Next Up</h3>
          <div class="question next-up" data-id="${question.id}">
            <div class="question-text">${question.text} | <span class="vote-count">Votes: ${question.upvotes}</span></div>
            <div class="username">Submitted by: ${question.username}</div>
            <div class="timestamp">Submitted on: ${new Date(question.created_at).toLocaleString()}</div>
            <div class="buttons">
              <button onclick="markAsLive('${question.id}')">Make Live</button>
              <button onclick="cancelNextUp('${question.id}')">Cancel Next Up</button>
            </div>
          </div>
        `;
      } else {
        nextUpArea.innerHTML = '';
      }
    });

    // Keep latest themes until selects are populated
    let pendingThemes = null;

    // Apply theme updates from server (store pending and apply when selects populated)
    socket.on('theme_updated', (themes) => {
      if (!themes) return;
      pendingThemes = themes;
      // Apply moderator view theme immediately if possible
      const link = document.getElementById('theme-stylesheet');
      if (link && themes['moderator']) link.href = '/themes/' + themes['moderator'];
      // If selects are already populated, set their values (extract filename from full path)
      const sIndex = document.getElementById('theme-index');
      if (sIndex && sIndex.options.length) sIndex.value = themes.user ? themes.user.split('/').pop() : sIndex.value;
      const sLive = document.getElementById('theme-live');
      if (sLive && sLive.options.length) sLive.value = themes.live ? themes.live.split('/').pop() : sLive.value;
      const sModerator = document.getElementById('theme-moderator');
      if (sModerator && sModerator.options.length) sModerator.value = themes.moderator ? themes.moderator.split('/').pop() : sModerator.value;
      const sPresenter = document.getElementById('theme-presenter');
      if (sPresenter && sPresenter.options.length) sPresenter.value = themes.presenter ? themes.presenter.split('/').pop() : sPresenter.value;
    });

    // Populate theme selects dynamically when available
    socket.on('available_themes', (themes) => {
      if (!themes || typeof themes !== 'object') return;
      const sIndex = document.getElementById('theme-index');
      const sLive = document.getElementById('theme-live');
      const sModerator = document.getElementById('theme-moderator');
      const sPresenter = document.getElementById('theme-presenter');

      function populate(selectEl, themeList) {
        if (!selectEl || !themeList) return;
        selectEl.innerHTML = '';
        themeList.forEach(t => {
          const opt = document.createElement('option');
          opt.value = t;
          opt.textContent = t.replace('.css','');
          selectEl.appendChild(opt);
        });
      }

      populate(sIndex, themes.user || []);
      populate(sLive, themes.live || []);
      populate(sModerator, themes.moderator || []);
      populate(sPresenter, themes.presenter || []);

      // If we have pending themes from server, set selects to those
      if (pendingThemes) {
        if (pendingThemes.user && sIndex.querySelector(`option[value="${pendingThemes.user}"]`)) sIndex.value = pendingThemes.user;
        if (pendingThemes.live && sLive.querySelector(`option[value="${pendingThemes.live}"]`)) sLive.value = pendingThemes.live;
        if (pendingThemes.moderator && sModerator.querySelector(`option[value="${pendingThemes.moderator}"]`)) sModerator.value = pendingThemes.moderator;
        if (pendingThemes.presenter && sPresenter.querySelector(`option[value="${pendingThemes.presenter}"]`)) sPresenter.value = pendingThemes.presenter;
      }
    });

    // Update the question list based on the current sort order
    function updateQuestionList(questions) {
      const container = document.getElementById('questions');
      container.innerHTML = '';

      const nonLiveQuestions = questions.filter(q => q.status !== 'live' && q.status !== 'next_up');

      nonLiveQuestions.forEach((q) => {
        const div = document.createElement('div');
        div.className = 'question';
        div.setAttribute('data-id', q.id); // Add a data-id attribute

        // Debugging: Log the participant IDs being compared
        console.log('Moderator receiving a question participantID:', q.participant_id);

        // Add styles for live and approved questions
        if (q.status === 'live') {
          div.classList.add('live'); // Highlight live questions
        }
        if (q.status === 'approved') {
          div.classList.add('approved'); // Style approved questions
        }
        if (q.status === 'next_up') {
          div.classList.add('next-up'); // Style next up questions
        }

        // Render buttons conditionally
        let buttons = '';
        if (q.status === 'live') {
          buttons = `
            <div class="buttons">
              <button onclick="cancelLive('${q.id}')">Cancel</button>
              <button onclick="archive_question('${q.id}')">Archive</button>
            </div>
          `;
        } else {
          buttons = `
            <div class="buttons">
              <button onclick="markAsLive('${q.id}')">Live</button>
              ${q.status === 'approved' 
                ? `<button onclick="unapprove('${q.id}')">Unapprove</button>` 
                : `<button onclick="approve('${q.id}')">Approve</button>`}
              <button onclick="delete_question('${q.id}')">Delete</button>
              ${q.status !== 'live' && q.status !== 'next_up'
                ? `<button onclick="editQuestion('${q.id}')">Edit</button>` 
                : ''}
              ${q.status === 'submitted' || q.status === 'approved'
                ? `<button onclick="markAsNextUp('${q.id}')">Next Up</button>`
                : ''}
            </div>
          `;
        }

        div.innerHTML = `
          <div class="question-text">${q.text} | <span class="vote-count">Votes: ${q.upvotes}</span></div>
          <div class="username">Submitted by: ${q.username}</div>
          <div class="timestamp">Submitted on: ${new Date(q.created_at).toLocaleString()}</div>
          ${buttons}
        `;
        container.appendChild(div);
      });
    }

    // Mark a question as live
    function markAsLive(id) {
      socket.emit('moderator_action', { id, action: 'live', sortBy: currentSort });
    }

    // Mark a question as next up
    function markAsNextUp(id) {
      socket.emit('moderator_action', { id, action: 'next_up', sortBy: currentSort });
    }

    // Cancel next up status
    function cancelNextUp(id) {
      socket.emit('moderator_action', { id, action: 'cancel_next_up', sortBy: currentSort });
    }

    // Cancel live status
    function cancelLive(id) {
      socket.emit('moderator_action', { id, action: 'cancel_live', sortBy: currentSort });
    }

    // Approve a question
    function approve(id) {
      socket.emit('moderator_action', { id, action: 'approved', sortBy: currentSort });
    }

    // Unapprove a question
    function unapprove(id) {
      socket.emit('moderator_action', { id, action: 'unapprove', sortBy: currentSort });
    }

    // delete a question
    function delete_question(id) {
      socket.emit('moderator_action', { id, action: 'questiondeleted', sortBy: currentSort });
    }

    // Archive a question
    function archive_question(id) {
      socket.emit('moderator_action', { id, action: 'cancel_live', sortBy: currentSort });
      socket.emit('moderator_action', { id, action: 'archive', sortBy: currentSort });
    }

    // Change the sort order
    function changeSort(order) {
      currentSort = order; // Update the current sort order
      socket.emit('request_questions', { sortBy: currentSort }); // Request sorted questions from the server
    }

    // Update vote count in real-time
    socket.on('update_vote', (updatedQuestion) => {
      // Find the question element in the DOM
      const questionElement = document.querySelector(`.question[data-id="${updatedQuestion.id}"]`);
      if (questionElement) {
        // Update the vote count in the DOM
        const voteCountElement = questionElement.querySelector('.vote-count');
        if (voteCountElement) {
          voteCountElement.textContent = `Votes: ${updatedQuestion.upvotes}`;
        }
      }
    });

    // Toggle Configure Event Section
    function toggleConfigureEvent() {
      const configDiv = document.getElementById('configure-event');
      const button = document.getElementById('configure-event-button');

      if (configDiv.style.display === 'none') {
        configDiv.style.display = 'block';
        button.textContent = 'Close Configuration';
      } else {
        configDiv.style.display = 'none';
        button.textContent = 'Configure Event';
      }
    }

    // Show toast notification
    function showToast(message, duration = 3000) {
      const toast = document.getElementById('toast');
      if (!toast) return;
      toast.textContent = message;
      toast.classList.add('show');
      setTimeout(() => {
        toast.classList.remove('show');
      }, duration);
    }

    // Save Event Configuration
    function saveEventConfig() {
      const modeventName = document.getElementById('event-name').value;
      const moderatorEventURL = document.getElementById('event-url-field').value;
      const modeventDatetime = document.getElementById('event-datetime').value;
      const eventName = document.getElementById('event-name').value;
      const eventURL = document.getElementById('event-url-field').value;
      const eventDatetime = document.getElementById('event-datetime').value;
      // Gather theme selections with proper folder paths
      const themes = {
        user: document.getElementById('theme-index') ? 'user/' + document.getElementById('theme-index').value : 'user/default.css',
        live: document.getElementById('theme-live') ? 'live/' + document.getElementById('theme-live').value : 'live/default.css',
        moderator: document.getElementById('theme-moderator') ? 'moderator/' + document.getElementById('theme-moderator').value : 'moderator/default.css',
        presenter: document.getElementById('theme-presenter') ? 'presenter/' + document.getElementById('theme-presenter').value : 'presenter/default.css'
      };

      // Emit the event to the server with the event configuration values and themes
      socket.emit('save_event_config', { eventName, eventURL, eventDatetime, themes });

      // Save values to localStorage
      localStorage.setItem('modeventName', modeventName);
      localStorage.setItem('modeventURL', moderatorEventURL);
      localStorage.setItem('modeventDatetime', modeventDatetime);

      showToast('Event configuration updated!');
    }

    function loadEventConfig() {
      const modeventName = localStorage.getItem('modeventName') || 'VBC Live Event';
      const moderatorEventURL = localStorage.getItem('moderatorEventURL') || 'e.g. 10.10.20.20';
      const modeventDatetime = localStorage.getItem('modeventDatetime') || '';
      // Populate the fields with values from localStorage or default values
      document.getElementById('event-name').value = modeventName;
      document.getElementById('event-url-field').value = moderatorEventURL;
      document.getElementById('event-datetime').value = modeventDatetime;
    }

    // Call loadEventConfig when the page loads
    window.onload = loadEventConfig;

    function exportQuestions() {
      // Fetch all questions and archived questions from the server
      socket.emit('request_export_data');

      // Listen for the server response
      socket.on('export_data', ({ questions, archivedQuestions }) => {
        // Combine questions and archived questions into a single array
        const allQuestions = [
          ...questions.map(q => ({
            id: q.id,
            username: q.username || 'Anonymous',
            text: q.text,
            status: q.status,
            upvotes: q.upvotes,
            created_at: new Date(q.created_at).toLocaleString(),
          })),
          ...archivedQuestions.map(q => ({
            id: q.id,
            username: q.username || 'Anonymous',
            text: q.text,
            status: q.status,
            upvotes: q.upvotes,
            created_at: new Date(q.created_at).toLocaleString(),
            archived_at: new Date(q.archived_at).toLocaleString(),
          })),
        ];

        // Convert the data to CSV format
        const csvContent = convertToCSV(allQuestions);

        // Create a downloadable link for the CSV file
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'questions_export.csv';
        link.style.display = 'none';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      });
    }

    // Helper function to convert data to CSV format
    function convertToCSV(data) {
      const headers = Object.keys(data[0]).join(','); // Extract headers from the first object
      const rows = data.map(row => Object.values(row).join(',')); // Convert each object to a CSV row
      return [headers, ...rows].join('\n'); // Combine headers and rows into a single CSV string
    }
  </script>

  <!-- Toggle Archived Questions Button -->
  <button id="toggle-archived" onclick="toggleArchivedQuestions()">Show Archived Questions</button>

  <!-- Archived Questions Section -->
  <div id="archived-questions" style="display: none; margin-top: 20px;">

    <h3>Archived Questions</h3>
    <div id="archived-questions-list"></div>
  </div>

  <script>
    let archivedVisible = false;

    function toggleArchivedQuestions() {
      const archivedContainer = document.getElementById('archived-questions');
      const toggleButton = document.getElementById('toggle-archived');

      if (archivedVisible) {
        archivedContainer.style.display = 'none';
        toggleButton.textContent = 'Show Archived Questions';
      } else {
        // Fetch archived questions from the server when showing the list
        socket.emit('request_archived_questions');
        archivedContainer.style.display = 'block';
        toggleButton.textContent = 'Hide Archived Questions';
      }

      archivedVisible = !archivedVisible;
    }

    socket.on('archived_questions', (questions) => {
      const container = document.getElementById('archived-questions-list');
      container.innerHTML = '';

      questions.forEach((q) => {
        const div = document.createElement('div');
        div.className = 'archived-question';
        div.innerHTML = `
          <div>${q.text}</div>
          <div class="archived-date">Archived on: ${new Date(q.archived_at).toLocaleString()}</div>
          <button onclick="unarchiveQuestion('${q.id}')">Unarchive</button>
        `;
        container.appendChild(div);
      });
      
    });

    function unarchiveQuestion(id) {
      socket.emit('moderator_action', { id, action: 'unarchive', sortBy: currentSort });
    }

    // Function to enable editing of a question
    function editQuestion(id) {
      const questionElement = document.querySelector(`.question[data-id="${id}"]`);
      if (!questionElement) return;

      const questionTextElement = questionElement.querySelector('.question-text');
      const originalText = questionTextElement.textContent.split(' | ')[0]; // Get original text, excluding votes

      // Create a textarea for editing
      const textarea = document.createElement('textarea');
      textarea.value = originalText;
      textarea.rows = 3;
      textarea.style.width = '100%';
      textarea.style.boxSizing = 'border-box'; // Include padding and border in the element's total width and height

      // Replace the question text with the textarea
      questionTextElement.innerHTML = '';
      questionTextElement.appendChild(textarea);

      // Hide Edit button, show Save and Cancel
      const buttonsDiv = questionElement.querySelector('.buttons');
      buttonsDiv.querySelector('button[onclick*="editQuestion"]').style.display = 'none';

      const saveButton = document.createElement('button');
      saveButton.textContent = 'Save';
      saveButton.onclick = () => saveEditedQuestion(id, textarea.value);
      buttonsDiv.appendChild(saveButton);

      const cancelButton = document.createElement('button');
      cancelButton.textContent = 'Cancel';
      cancelButton.onclick = () => cancelEdit(id, originalText);
      buttonsDiv.appendChild(cancelButton);
    }

    // Function to save the edited question
    function saveEditedQuestion(id, newText) {
      socket.emit('moderator_action', { id, action: 'edit', newText, sortBy: currentSort });
    }

    // Function to cancel editing a question
    function cancelEdit(id, originalText) {
      const questionElement = document.querySelector(`.question[data-id="${id}"]`);
      if (!questionElement) return;

      const questionTextElement = questionElement.querySelector('.question-text');
      // Restore original text
      questionTextElement.innerHTML = `${originalText} | <span class="vote-count">Votes: ${questionElement.querySelector('.vote-count').textContent.split(': ')[1]}</span>`;

      // Show Edit button, hide Save and Cancel
      const buttonsDiv = questionElement.querySelector('.buttons');
      buttonsDiv.querySelector('button[onclick*="editQuestion"]').style.display = '';
      buttonsDiv.querySelector('button[onclick*="saveEditedQuestion"]').remove();
      buttonsDiv.querySelector('button[onclick*="cancelEdit"]').remove();
    }
  </script>

  <!-- Export Questions Button -->
  <div id="export-controls" style="margin-top: 20px;">
    <button onclick="exportQuestions()">Export Questions</button>
  </div>
  
</body>
</html>